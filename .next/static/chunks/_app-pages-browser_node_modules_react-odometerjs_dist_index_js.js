/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_react-odometerjs_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/odometer/odometer.js":
/*!*******************************************!*\
  !*** ./node_modules/odometer/odometer.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  var COUNT_FRAMERATE, COUNT_MS_PER_FRAME, DIGIT_FORMAT, DIGIT_HTML, DIGIT_SPEEDBOOST, DURATION, FORMAT_MARK_HTML, FORMAT_PARSER, FRAMERATE, FRAMES_PER_VALUE, MS_PER_FRAME, MutationObserver, Odometer, RIBBON_HTML, TRANSITION_END_EVENTS, TRANSITION_SUPPORT, VALUE_HTML, addClass, createFromHTML, fractionalPart, now, removeClass, requestAnimationFrame, round, transitionCheckStyles, trigger, truncate, wrapJQuery, _jQueryWrapped, _old, _ref, _ref1,\n    __slice = [].slice;\n\n  VALUE_HTML = '<span class=\"odometer-value\"></span>';\n\n  RIBBON_HTML = '<span class=\"odometer-ribbon\"><span class=\"odometer-ribbon-inner\">' + VALUE_HTML + '</span></span>';\n\n  DIGIT_HTML = '<span class=\"odometer-digit\"><span class=\"odometer-digit-spacer\">8</span><span class=\"odometer-digit-inner\">' + RIBBON_HTML + '</span></span>';\n\n  FORMAT_MARK_HTML = '<span class=\"odometer-formatting-mark\"></span>';\n\n  DIGIT_FORMAT = '(,ddd).dd';\n\n  FORMAT_PARSER = /^\\(?([^)]*)\\)?(?:(.)(d+))?$/;\n\n  FRAMERATE = 30;\n\n  DURATION = 2000;\n\n  COUNT_FRAMERATE = 20;\n\n  FRAMES_PER_VALUE = 2;\n\n  DIGIT_SPEEDBOOST = .5;\n\n  MS_PER_FRAME = 1000 / FRAMERATE;\n\n  COUNT_MS_PER_FRAME = 1000 / COUNT_FRAMERATE;\n\n  TRANSITION_END_EVENTS = 'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd';\n\n  transitionCheckStyles = document.createElement('div').style;\n\n  TRANSITION_SUPPORT = (transitionCheckStyles.transition != null) || (transitionCheckStyles.webkitTransition != null) || (transitionCheckStyles.mozTransition != null) || (transitionCheckStyles.oTransition != null);\n\n  requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\n  MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n\n  createFromHTML = function(html) {\n    var el;\n    el = document.createElement('div');\n    el.innerHTML = html;\n    return el.children[0];\n  };\n\n  removeClass = function(el, name) {\n    return el.className = el.className.replace(new RegExp(\"(^| )\" + (name.split(' ').join('|')) + \"( |$)\", 'gi'), ' ');\n  };\n\n  addClass = function(el, name) {\n    removeClass(el, name);\n    return el.className += \" \" + name;\n  };\n\n  trigger = function(el, name) {\n    var evt;\n    if (document.createEvent != null) {\n      evt = document.createEvent('HTMLEvents');\n      evt.initEvent(name, true, true);\n      return el.dispatchEvent(evt);\n    }\n  };\n\n  now = function() {\n    var _ref, _ref1;\n    return (_ref = (_ref1 = window.performance) != null ? typeof _ref1.now === \"function\" ? _ref1.now() : void 0 : void 0) != null ? _ref : +(new Date);\n  };\n\n  round = function(val, precision) {\n    if (precision == null) {\n      precision = 0;\n    }\n    if (!precision) {\n      return Math.round(val);\n    }\n    val *= Math.pow(10, precision);\n    val += 0.5;\n    val = Math.floor(val);\n    return val /= Math.pow(10, precision);\n  };\n\n  truncate = function(val) {\n    if (val < 0) {\n      return Math.ceil(val);\n    } else {\n      return Math.floor(val);\n    }\n  };\n\n  fractionalPart = function(val) {\n    return val - round(val);\n  };\n\n  _jQueryWrapped = false;\n\n  (wrapJQuery = function() {\n    var property, _i, _len, _ref, _results;\n    if (_jQueryWrapped) {\n      return;\n    }\n    if (window.jQuery != null) {\n      _jQueryWrapped = true;\n      _ref = ['html', 'text'];\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        property = _ref[_i];\n        _results.push((function(property) {\n          var old;\n          old = window.jQuery.fn[property];\n          return window.jQuery.fn[property] = function(val) {\n            var _ref1;\n            if ((val == null) || (((_ref1 = this[0]) != null ? _ref1.odometer : void 0) == null)) {\n              return old.apply(this, arguments);\n            }\n            return this[0].odometer.update(val);\n          };\n        })(property));\n      }\n      return _results;\n    }\n  })();\n\n  setTimeout(wrapJQuery, 0);\n\n  Odometer = (function() {\n    function Odometer(options) {\n      var e, k, property, v, _base, _i, _len, _ref, _ref1, _ref2,\n        _this = this;\n      this.options = options;\n      this.el = this.options.el;\n      if (this.el.odometer != null) {\n        return this.el.odometer;\n      }\n      this.el.odometer = this;\n      _ref = Odometer.options;\n      for (k in _ref) {\n        v = _ref[k];\n        if (this.options[k] == null) {\n          this.options[k] = v;\n        }\n      }\n      if ((_base = this.options).duration == null) {\n        _base.duration = DURATION;\n      }\n      this.MAX_VALUES = ((this.options.duration / MS_PER_FRAME) / FRAMES_PER_VALUE) | 0;\n      this.resetFormat();\n      this.value = this.cleanValue((_ref1 = this.options.value) != null ? _ref1 : '');\n      this.renderInside();\n      this.render();\n      try {\n        _ref2 = ['innerHTML', 'innerText', 'textContent'];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          property = _ref2[_i];\n          if (this.el[property] != null) {\n            (function(property) {\n              return Object.defineProperty(_this.el, property, {\n                get: function() {\n                  var _ref3;\n                  if (property === 'innerHTML') {\n                    return _this.inside.outerHTML;\n                  } else {\n                    return (_ref3 = _this.inside.innerText) != null ? _ref3 : _this.inside.textContent;\n                  }\n                },\n                set: function(val) {\n                  return _this.update(val);\n                }\n              });\n            })(property);\n          }\n        }\n      } catch (_error) {\n        e = _error;\n        this.watchForMutations();\n      }\n      this;\n    }\n\n    Odometer.prototype.renderInside = function() {\n      this.inside = document.createElement('div');\n      this.inside.className = 'odometer-inside';\n      this.el.innerHTML = '';\n      return this.el.appendChild(this.inside);\n    };\n\n    Odometer.prototype.watchForMutations = function() {\n      var e,\n        _this = this;\n      if (MutationObserver == null) {\n        return;\n      }\n      try {\n        if (this.observer == null) {\n          this.observer = new MutationObserver(function(mutations) {\n            var newVal;\n            newVal = _this.el.innerText;\n            _this.renderInside();\n            _this.render(_this.value);\n            return _this.update(newVal);\n          });\n        }\n        this.watchMutations = true;\n        return this.startWatchingMutations();\n      } catch (_error) {\n        e = _error;\n      }\n    };\n\n    Odometer.prototype.startWatchingMutations = function() {\n      if (this.watchMutations) {\n        return this.observer.observe(this.el, {\n          childList: true\n        });\n      }\n    };\n\n    Odometer.prototype.stopWatchingMutations = function() {\n      var _ref;\n      return (_ref = this.observer) != null ? _ref.disconnect() : void 0;\n    };\n\n    Odometer.prototype.cleanValue = function(val) {\n      var _ref;\n      if (typeof val === 'string') {\n        val = val.replace((_ref = this.format.radix) != null ? _ref : '.', '<radix>');\n        val = val.replace(/[.,]/g, '');\n        val = val.replace('<radix>', '.');\n        val = parseFloat(val, 10) || 0;\n      }\n      return round(val, this.format.precision);\n    };\n\n    Odometer.prototype.bindTransitionEnd = function() {\n      var event, renderEnqueued, _i, _len, _ref, _results,\n        _this = this;\n      if (this.transitionEndBound) {\n        return;\n      }\n      this.transitionEndBound = true;\n      renderEnqueued = false;\n      _ref = TRANSITION_END_EVENTS.split(' ');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        event = _ref[_i];\n        _results.push(this.el.addEventListener(event, function() {\n          if (renderEnqueued) {\n            return true;\n          }\n          renderEnqueued = true;\n          setTimeout(function() {\n            _this.render();\n            renderEnqueued = false;\n            return trigger(_this.el, 'odometerdone');\n          }, 0);\n          return true;\n        }, false));\n      }\n      return _results;\n    };\n\n    Odometer.prototype.resetFormat = function() {\n      var format, fractional, parsed, precision, radix, repeating, _ref, _ref1;\n      format = (_ref = this.options.format) != null ? _ref : DIGIT_FORMAT;\n      format || (format = 'd');\n      parsed = FORMAT_PARSER.exec(format);\n      if (!parsed) {\n        throw new Error(\"Odometer: Unparsable digit format\");\n      }\n      _ref1 = parsed.slice(1, 4), repeating = _ref1[0], radix = _ref1[1], fractional = _ref1[2];\n      precision = (fractional != null ? fractional.length : void 0) || 0;\n      return this.format = {\n        repeating: repeating,\n        radix: radix,\n        precision: precision\n      };\n    };\n\n    Odometer.prototype.render = function(value) {\n      var classes, cls, match, newClasses, theme, _i, _len;\n      if (value == null) {\n        value = this.value;\n      }\n      this.stopWatchingMutations();\n      this.resetFormat();\n      this.inside.innerHTML = '';\n      theme = this.options.theme;\n      classes = this.el.className.split(' ');\n      newClasses = [];\n      for (_i = 0, _len = classes.length; _i < _len; _i++) {\n        cls = classes[_i];\n        if (!cls.length) {\n          continue;\n        }\n        if (match = /^odometer-theme-(.+)$/.exec(cls)) {\n          theme = match[1];\n          continue;\n        }\n        if (/^odometer(-|$)/.test(cls)) {\n          continue;\n        }\n        newClasses.push(cls);\n      }\n      newClasses.push('odometer');\n      if (!TRANSITION_SUPPORT) {\n        newClasses.push('odometer-no-transitions');\n      }\n      if (theme) {\n        newClasses.push(\"odometer-theme-\" + theme);\n      } else {\n        newClasses.push(\"odometer-auto-theme\");\n      }\n      this.el.className = newClasses.join(' ');\n      this.ribbons = {};\n      this.formatDigits(value);\n      return this.startWatchingMutations();\n    };\n\n    Odometer.prototype.formatDigits = function(value) {\n      var digit, valueDigit, valueString, wholePart, _i, _j, _len, _len1, _ref, _ref1;\n      this.digits = [];\n      if (this.options.formatFunction) {\n        valueString = this.options.formatFunction(value);\n        _ref = valueString.split('').reverse();\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          valueDigit = _ref[_i];\n          if (valueDigit.match(/0-9/)) {\n            digit = this.renderDigit();\n            digit.querySelector('.odometer-value').innerHTML = valueDigit;\n            this.digits.push(digit);\n            this.insertDigit(digit);\n          } else {\n            this.addSpacer(valueDigit);\n          }\n        }\n      } else {\n        wholePart = !this.format.precision || !fractionalPart(value) || false;\n        _ref1 = value.toString().split('').reverse();\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          digit = _ref1[_j];\n          if (digit === '.') {\n            wholePart = true;\n          }\n          this.addDigit(digit, wholePart);\n        }\n      }\n    };\n\n    Odometer.prototype.update = function(newValue) {\n      var diff,\n        _this = this;\n      newValue = this.cleanValue(newValue);\n      if (!(diff = newValue - this.value)) {\n        return;\n      }\n      removeClass(this.el, 'odometer-animating-up odometer-animating-down odometer-animating');\n      if (diff > 0) {\n        addClass(this.el, 'odometer-animating-up');\n      } else {\n        addClass(this.el, 'odometer-animating-down');\n      }\n      this.stopWatchingMutations();\n      this.animate(newValue);\n      this.startWatchingMutations();\n      setTimeout(function() {\n        _this.el.offsetHeight;\n        return addClass(_this.el, 'odometer-animating');\n      }, 0);\n      return this.value = newValue;\n    };\n\n    Odometer.prototype.renderDigit = function() {\n      return createFromHTML(DIGIT_HTML);\n    };\n\n    Odometer.prototype.insertDigit = function(digit, before) {\n      if (before != null) {\n        return this.inside.insertBefore(digit, before);\n      } else if (!this.inside.children.length) {\n        return this.inside.appendChild(digit);\n      } else {\n        return this.inside.insertBefore(digit, this.inside.children[0]);\n      }\n    };\n\n    Odometer.prototype.addSpacer = function(chr, before, extraClasses) {\n      var spacer;\n      spacer = createFromHTML(FORMAT_MARK_HTML);\n      spacer.innerHTML = chr;\n      if (extraClasses) {\n        addClass(spacer, extraClasses);\n      }\n      return this.insertDigit(spacer, before);\n    };\n\n    Odometer.prototype.addDigit = function(value, repeating) {\n      var chr, digit, resetted, _ref;\n      if (repeating == null) {\n        repeating = true;\n      }\n      if (value === '-') {\n        return this.addSpacer(value, null, 'odometer-negation-mark');\n      }\n      if (value === '.') {\n        return this.addSpacer((_ref = this.format.radix) != null ? _ref : '.', null, 'odometer-radix-mark');\n      }\n      if (repeating) {\n        resetted = false;\n        while (true) {\n          if (!this.format.repeating.length) {\n            if (resetted) {\n              throw new Error(\"Bad odometer format without digits\");\n            }\n            this.resetFormat();\n            resetted = true;\n          }\n          chr = this.format.repeating[this.format.repeating.length - 1];\n          this.format.repeating = this.format.repeating.substring(0, this.format.repeating.length - 1);\n          if (chr === 'd') {\n            break;\n          }\n          this.addSpacer(chr);\n        }\n      }\n      digit = this.renderDigit();\n      digit.querySelector('.odometer-value').innerHTML = value;\n      this.digits.push(digit);\n      return this.insertDigit(digit);\n    };\n\n    Odometer.prototype.animate = function(newValue) {\n      if (!TRANSITION_SUPPORT || this.options.animation === 'count') {\n        return this.animateCount(newValue);\n      } else {\n        return this.animateSlide(newValue);\n      }\n    };\n\n    Odometer.prototype.animateCount = function(newValue) {\n      var cur, diff, last, start, tick,\n        _this = this;\n      if (!(diff = +newValue - this.value)) {\n        return;\n      }\n      start = last = now();\n      cur = this.value;\n      return (tick = function() {\n        var delta, dist, fraction;\n        if ((now() - start) > _this.options.duration) {\n          _this.value = newValue;\n          _this.render();\n          trigger(_this.el, 'odometerdone');\n          return;\n        }\n        delta = now() - last;\n        if (delta > COUNT_MS_PER_FRAME) {\n          last = now();\n          fraction = delta / _this.options.duration;\n          dist = diff * fraction;\n          cur += dist;\n          _this.render(Math.round(cur));\n        }\n        if (requestAnimationFrame != null) {\n          return requestAnimationFrame(tick);\n        } else {\n          return setTimeout(tick, COUNT_MS_PER_FRAME);\n        }\n      })();\n    };\n\n    Odometer.prototype.getDigitCount = function() {\n      var i, max, value, values, _i, _len;\n      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {\n        value = values[i];\n        values[i] = Math.abs(value);\n      }\n      max = Math.max.apply(Math, values);\n      return Math.ceil(Math.log(max + 1) / Math.log(10));\n    };\n\n    Odometer.prototype.getFractionalDigitCount = function() {\n      var i, parser, parts, value, values, _i, _len;\n      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      parser = /^\\-?\\d*\\.(\\d*?)0*$/;\n      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {\n        value = values[i];\n        values[i] = value.toString();\n        parts = parser.exec(values[i]);\n        if (parts == null) {\n          values[i] = 0;\n        } else {\n          values[i] = parts[1].length;\n        }\n      }\n      return Math.max.apply(Math, values);\n    };\n\n    Odometer.prototype.resetDigits = function() {\n      this.digits = [];\n      this.ribbons = [];\n      this.inside.innerHTML = '';\n      return this.resetFormat();\n    };\n\n    Odometer.prototype.animateSlide = function(newValue) {\n      var boosted, cur, diff, digitCount, digits, dist, end, fractionalCount, frame, frames, i, incr, j, mark, numEl, oldValue, start, _base, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _results;\n      oldValue = this.value;\n      fractionalCount = this.getFractionalDigitCount(oldValue, newValue);\n      if (fractionalCount) {\n        newValue = newValue * Math.pow(10, fractionalCount);\n        oldValue = oldValue * Math.pow(10, fractionalCount);\n      }\n      if (!(diff = newValue - oldValue)) {\n        return;\n      }\n      this.bindTransitionEnd();\n      digitCount = this.getDigitCount(oldValue, newValue);\n      digits = [];\n      boosted = 0;\n      for (i = _i = 0; 0 <= digitCount ? _i < digitCount : _i > digitCount; i = 0 <= digitCount ? ++_i : --_i) {\n        start = truncate(oldValue / Math.pow(10, digitCount - i - 1));\n        end = truncate(newValue / Math.pow(10, digitCount - i - 1));\n        dist = end - start;\n        if (Math.abs(dist) > this.MAX_VALUES) {\n          frames = [];\n          incr = dist / (this.MAX_VALUES + this.MAX_VALUES * boosted * DIGIT_SPEEDBOOST);\n          cur = start;\n          while ((dist > 0 && cur < end) || (dist < 0 && cur > end)) {\n            frames.push(Math.round(cur));\n            cur += incr;\n          }\n          if (frames[frames.length - 1] !== end) {\n            frames.push(end);\n          }\n          boosted++;\n        } else {\n          frames = (function() {\n            _results = [];\n            for (var _j = start; start <= end ? _j <= end : _j >= end; start <= end ? _j++ : _j--){ _results.push(_j); }\n            return _results;\n          }).apply(this);\n        }\n        for (i = _k = 0, _len = frames.length; _k < _len; i = ++_k) {\n          frame = frames[i];\n          frames[i] = Math.abs(frame % 10);\n        }\n        digits.push(frames);\n      }\n      this.resetDigits();\n      _ref = digits.reverse();\n      for (i = _l = 0, _len1 = _ref.length; _l < _len1; i = ++_l) {\n        frames = _ref[i];\n        if (!this.digits[i]) {\n          this.addDigit(' ', i >= fractionalCount);\n        }\n        if ((_base = this.ribbons)[i] == null) {\n          _base[i] = this.digits[i].querySelector('.odometer-ribbon-inner');\n        }\n        this.ribbons[i].innerHTML = '';\n        if (diff < 0) {\n          frames = frames.reverse();\n        }\n        for (j = _m = 0, _len2 = frames.length; _m < _len2; j = ++_m) {\n          frame = frames[j];\n          numEl = document.createElement('div');\n          numEl.className = 'odometer-value';\n          numEl.innerHTML = frame;\n          this.ribbons[i].appendChild(numEl);\n          if (j === frames.length - 1) {\n            addClass(numEl, 'odometer-last-value');\n          }\n          if (j === 0) {\n            addClass(numEl, 'odometer-first-value');\n          }\n        }\n      }\n      if (start < 0) {\n        this.addDigit('-');\n      }\n      mark = this.inside.querySelector('.odometer-radix-mark');\n      if (mark != null) {\n        mark.parent.removeChild(mark);\n      }\n      if (fractionalCount) {\n        return this.addSpacer(this.format.radix, this.digits[fractionalCount - 1], 'odometer-radix-mark');\n      }\n    };\n\n    return Odometer;\n\n  })();\n\n  Odometer.options = (_ref = window.odometerOptions) != null ? _ref : {};\n\n  setTimeout(function() {\n    var k, v, _base, _ref1, _results;\n    if (window.odometerOptions) {\n      _ref1 = window.odometerOptions;\n      _results = [];\n      for (k in _ref1) {\n        v = _ref1[k];\n        _results.push((_base = Odometer.options)[k] != null ? (_base = Odometer.options)[k] : _base[k] = v);\n      }\n      return _results;\n    }\n  }, 0);\n\n  Odometer.init = function() {\n    var el, elements, _i, _len, _ref1, _results;\n    if (document.querySelectorAll == null) {\n      return;\n    }\n    elements = document.querySelectorAll(Odometer.options.selector || '.odometer');\n    _results = [];\n    for (_i = 0, _len = elements.length; _i < _len; _i++) {\n      el = elements[_i];\n      _results.push(el.odometer = new Odometer({\n        el: el,\n        value: (_ref1 = el.innerText) != null ? _ref1 : el.textContent\n      }));\n    }\n    return _results;\n  };\n\n  if ((((_ref1 = document.documentElement) != null ? _ref1.doScroll : void 0) != null) && (document.createEventObject != null)) {\n    _old = document.onreadystatechange;\n    document.onreadystatechange = function() {\n      if (document.readyState === 'complete' && Odometer.options.auto !== false) {\n        Odometer.init();\n      }\n      return _old != null ? _old.apply(this, arguments) : void 0;\n    };\n  } else {\n    document.addEventListener('DOMContentLoaded', function() {\n      if (Odometer.options.auto !== false) {\n        return Odometer.init();\n      }\n    }, false);\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Odometer;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZG9tZXRlci9vZG9tZXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFxRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlDQUFpQyxzQ0FBc0MsNkJBQTZCO0FBQ3BHO0FBQ0EsV0FBVztBQUNYO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQU8sRUFBRSxtQ0FBRTtBQUNmO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sSUFBSSxLQUFLLEVBSU47O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb2RvbWV0ZXIvb2RvbWV0ZXIuanM/OGM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBDT1VOVF9GUkFNRVJBVEUsIENPVU5UX01TX1BFUl9GUkFNRSwgRElHSVRfRk9STUFULCBESUdJVF9IVE1MLCBESUdJVF9TUEVFREJPT1NULCBEVVJBVElPTiwgRk9STUFUX01BUktfSFRNTCwgRk9STUFUX1BBUlNFUiwgRlJBTUVSQVRFLCBGUkFNRVNfUEVSX1ZBTFVFLCBNU19QRVJfRlJBTUUsIE11dGF0aW9uT2JzZXJ2ZXIsIE9kb21ldGVyLCBSSUJCT05fSFRNTCwgVFJBTlNJVElPTl9FTkRfRVZFTlRTLCBUUkFOU0lUSU9OX1NVUFBPUlQsIFZBTFVFX0hUTUwsIGFkZENsYXNzLCBjcmVhdGVGcm9tSFRNTCwgZnJhY3Rpb25hbFBhcnQsIG5vdywgcmVtb3ZlQ2xhc3MsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgcm91bmQsIHRyYW5zaXRpb25DaGVja1N0eWxlcywgdHJpZ2dlciwgdHJ1bmNhdGUsIHdyYXBKUXVlcnksIF9qUXVlcnlXcmFwcGVkLCBfb2xkLCBfcmVmLCBfcmVmMSxcbiAgICBfX3NsaWNlID0gW10uc2xpY2U7XG5cbiAgVkFMVUVfSFRNTCA9ICc8c3BhbiBjbGFzcz1cIm9kb21ldGVyLXZhbHVlXCI+PC9zcGFuPic7XG5cbiAgUklCQk9OX0hUTUwgPSAnPHNwYW4gY2xhc3M9XCJvZG9tZXRlci1yaWJib25cIj48c3BhbiBjbGFzcz1cIm9kb21ldGVyLXJpYmJvbi1pbm5lclwiPicgKyBWQUxVRV9IVE1MICsgJzwvc3Bhbj48L3NwYW4+JztcblxuICBESUdJVF9IVE1MID0gJzxzcGFuIGNsYXNzPVwib2RvbWV0ZXItZGlnaXRcIj48c3BhbiBjbGFzcz1cIm9kb21ldGVyLWRpZ2l0LXNwYWNlclwiPjg8L3NwYW4+PHNwYW4gY2xhc3M9XCJvZG9tZXRlci1kaWdpdC1pbm5lclwiPicgKyBSSUJCT05fSFRNTCArICc8L3NwYW4+PC9zcGFuPic7XG5cbiAgRk9STUFUX01BUktfSFRNTCA9ICc8c3BhbiBjbGFzcz1cIm9kb21ldGVyLWZvcm1hdHRpbmctbWFya1wiPjwvc3Bhbj4nO1xuXG4gIERJR0lUX0ZPUk1BVCA9ICcoLGRkZCkuZGQnO1xuXG4gIEZPUk1BVF9QQVJTRVIgPSAvXlxcKD8oW14pXSopXFwpPyg/OiguKShkKykpPyQvO1xuXG4gIEZSQU1FUkFURSA9IDMwO1xuXG4gIERVUkFUSU9OID0gMjAwMDtcblxuICBDT1VOVF9GUkFNRVJBVEUgPSAyMDtcblxuICBGUkFNRVNfUEVSX1ZBTFVFID0gMjtcblxuICBESUdJVF9TUEVFREJPT1NUID0gLjU7XG5cbiAgTVNfUEVSX0ZSQU1FID0gMTAwMCAvIEZSQU1FUkFURTtcblxuICBDT1VOVF9NU19QRVJfRlJBTUUgPSAxMDAwIC8gQ09VTlRfRlJBTUVSQVRFO1xuXG4gIFRSQU5TSVRJT05fRU5EX0VWRU5UUyA9ICd0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kJztcblxuICB0cmFuc2l0aW9uQ2hlY2tTdHlsZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICBUUkFOU0lUSU9OX1NVUFBPUlQgPSAodHJhbnNpdGlvbkNoZWNrU3R5bGVzLnRyYW5zaXRpb24gIT0gbnVsbCkgfHwgKHRyYW5zaXRpb25DaGVja1N0eWxlcy53ZWJraXRUcmFuc2l0aW9uICE9IG51bGwpIHx8ICh0cmFuc2l0aW9uQ2hlY2tTdHlsZXMubW96VHJhbnNpdGlvbiAhPSBudWxsKSB8fCAodHJhbnNpdGlvbkNoZWNrU3R5bGVzLm9UcmFuc2l0aW9uICE9IG51bGwpO1xuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICBNdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgY3JlYXRlRnJvbUhUTUwgPSBmdW5jdGlvbihodG1sKSB7XG4gICAgdmFyIGVsO1xuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZWwuY2hpbGRyZW5bMF07XG4gIH07XG5cbiAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgIHJldHVybiBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58IClcIiArIChuYW1lLnNwbGl0KCcgJykuam9pbignfCcpKSArIFwiKCB8JClcIiwgJ2dpJyksICcgJyk7XG4gIH07XG5cbiAgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgbmFtZTtcbiAgfTtcblxuICB0cmlnZ2VyID0gZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICB2YXIgZXZ0O1xuICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCAhPSBudWxsKSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgIHJldHVybiBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICB9O1xuXG4gIG5vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfcmVmLCBfcmVmMTtcbiAgICByZXR1cm4gKF9yZWYgPSAoX3JlZjEgPSB3aW5kb3cucGVyZm9ybWFuY2UpICE9IG51bGwgPyB0eXBlb2YgX3JlZjEubm93ID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmMS5ub3coKSA6IHZvaWQgMCA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWYgOiArKG5ldyBEYXRlKTtcbiAgfTtcblxuICByb3VuZCA9IGZ1bmN0aW9uKHZhbCwgcHJlY2lzaW9uKSB7XG4gICAgaWYgKHByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICBwcmVjaXNpb24gPSAwO1xuICAgIH1cbiAgICBpZiAoIXByZWNpc2lvbikge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG4gICAgdmFsICo9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHZhbCArPSAwLjU7XG4gICAgdmFsID0gTWF0aC5mbG9vcih2YWwpO1xuICAgIHJldHVybiB2YWwgLz0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gIH07XG5cbiAgdHJ1bmNhdGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwpO1xuICAgIH1cbiAgfTtcblxuICBmcmFjdGlvbmFsUGFydCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWwgLSByb3VuZCh2YWwpO1xuICB9O1xuXG4gIF9qUXVlcnlXcmFwcGVkID0gZmFsc2U7XG5cbiAgKHdyYXBKUXVlcnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvcGVydHksIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICBpZiAoX2pRdWVyeVdyYXBwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5qUXVlcnkgIT0gbnVsbCkge1xuICAgICAgX2pRdWVyeVdyYXBwZWQgPSB0cnVlO1xuICAgICAgX3JlZiA9IFsnaHRtbCcsICd0ZXh0J107XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZltfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG9sZDtcbiAgICAgICAgICBvbGQgPSB3aW5kb3cualF1ZXJ5LmZuW3Byb3BlcnR5XTtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmpRdWVyeS5mbltwcm9wZXJ0eV0gPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMTtcbiAgICAgICAgICAgIGlmICgodmFsID09IG51bGwpIHx8ICgoKF9yZWYxID0gdGhpc1swXSkgIT0gbnVsbCA/IF9yZWYxLm9kb21ldGVyIDogdm9pZCAwKSA9PSBudWxsKSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZG9tZXRlci51cGRhdGUodmFsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KShwcm9wZXJ0eSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH1cbiAgfSkoKTtcblxuICBzZXRUaW1lb3V0KHdyYXBKUXVlcnksIDApO1xuXG4gIE9kb21ldGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE9kb21ldGVyKG9wdGlvbnMpIHtcbiAgICAgIHZhciBlLCBrLCBwcm9wZXJ0eSwgdiwgX2Jhc2UsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjIsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmVsID0gdGhpcy5vcHRpb25zLmVsO1xuICAgICAgaWYgKHRoaXMuZWwub2RvbWV0ZXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZG9tZXRlcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWwub2RvbWV0ZXIgPSB0aGlzO1xuICAgICAgX3JlZiA9IE9kb21ldGVyLm9wdGlvbnM7XG4gICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICB2ID0gX3JlZltrXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1trXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChfYmFzZSA9IHRoaXMub3B0aW9ucykuZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICBfYmFzZS5kdXJhdGlvbiA9IERVUkFUSU9OO1xuICAgICAgfVxuICAgICAgdGhpcy5NQVhfVkFMVUVTID0gKCh0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyBNU19QRVJfRlJBTUUpIC8gRlJBTUVTX1BFUl9WQUxVRSkgfCAwO1xuICAgICAgdGhpcy5yZXNldEZvcm1hdCgpO1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY2xlYW5WYWx1ZSgoX3JlZjEgPSB0aGlzLm9wdGlvbnMudmFsdWUpICE9IG51bGwgPyBfcmVmMSA6ICcnKTtcbiAgICAgIHRoaXMucmVuZGVySW5zaWRlKCk7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3JlZjIgPSBbJ2lubmVySFRNTCcsICdpbm5lclRleHQnLCAndGV4dENvbnRlbnQnXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHByb3BlcnR5ID0gX3JlZjJbX2ldO1xuICAgICAgICAgIGlmICh0aGlzLmVsW3Byb3BlcnR5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5lbCwgcHJvcGVydHksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW5zaWRlLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX3JlZjMgPSBfdGhpcy5pbnNpZGUuaW5uZXJUZXh0KSAhPSBudWxsID8gX3JlZjMgOiBfdGhpcy5pbnNpZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZSh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KShwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGhpcy53YXRjaEZvck11dGF0aW9ucygpO1xuICAgICAgfVxuICAgICAgdGhpcztcbiAgICB9XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUucmVuZGVySW5zaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluc2lkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5pbnNpZGUuY2xhc3NOYW1lID0gJ29kb21ldGVyLWluc2lkZSc7XG4gICAgICB0aGlzLmVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5pbnNpZGUpO1xuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUud2F0Y2hGb3JNdXRhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoTXV0YXRpb25PYnNlcnZlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24obXV0YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsO1xuICAgICAgICAgICAgbmV3VmFsID0gX3RoaXMuZWwuaW5uZXJUZXh0O1xuICAgICAgICAgICAgX3RoaXMucmVuZGVySW5zaWRlKCk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXIoX3RoaXMudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZShuZXdWYWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hNdXRhdGlvbnMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFdhdGNoaW5nTXV0YXRpb25zKCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnN0YXJ0V2F0Y2hpbmdNdXRhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLndhdGNoTXV0YXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5lbCwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnN0b3BXYXRjaGluZ011dGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICByZXR1cm4gKF9yZWYgPSB0aGlzLm9ic2VydmVyKSAhPSBudWxsID8gX3JlZi5kaXNjb25uZWN0KCkgOiB2b2lkIDA7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5jbGVhblZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgoX3JlZiA9IHRoaXMuZm9ybWF0LnJhZGl4KSAhPSBudWxsID8gX3JlZiA6ICcuJywgJzxyYWRpeD4nKTtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1suLF0vZywgJycpO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgnPHJhZGl4PicsICcuJyk7XG4gICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsLCAxMCkgfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3VuZCh2YWwsIHRoaXMuZm9ybWF0LnByZWNpc2lvbik7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5iaW5kVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCByZW5kZXJFbnF1ZXVlZCwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy50cmFuc2l0aW9uRW5kQm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9uRW5kQm91bmQgPSB0cnVlO1xuICAgICAgcmVuZGVyRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIF9yZWYgPSBUUkFOU0lUSU9OX0VORF9FVkVOVFMuc3BsaXQoJyAnKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZXZlbnQgPSBfcmVmW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChyZW5kZXJFbnF1ZXVlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbmRlckVucXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICByZW5kZXJFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXIoX3RoaXMuZWwsICdvZG9tZXRlcmRvbmUnKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnJlc2V0Rm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZm9ybWF0LCBmcmFjdGlvbmFsLCBwYXJzZWQsIHByZWNpc2lvbiwgcmFkaXgsIHJlcGVhdGluZywgX3JlZiwgX3JlZjE7XG4gICAgICBmb3JtYXQgPSAoX3JlZiA9IHRoaXMub3B0aW9ucy5mb3JtYXQpICE9IG51bGwgPyBfcmVmIDogRElHSVRfRk9STUFUO1xuICAgICAgZm9ybWF0IHx8IChmb3JtYXQgPSAnZCcpO1xuICAgICAgcGFyc2VkID0gRk9STUFUX1BBUlNFUi5leGVjKGZvcm1hdCk7XG4gICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZG9tZXRlcjogVW5wYXJzYWJsZSBkaWdpdCBmb3JtYXRcIik7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IHBhcnNlZC5zbGljZSgxLCA0KSwgcmVwZWF0aW5nID0gX3JlZjFbMF0sIHJhZGl4ID0gX3JlZjFbMV0sIGZyYWN0aW9uYWwgPSBfcmVmMVsyXTtcbiAgICAgIHByZWNpc2lvbiA9IChmcmFjdGlvbmFsICE9IG51bGwgPyBmcmFjdGlvbmFsLmxlbmd0aCA6IHZvaWQgMCkgfHwgMDtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdCA9IHtcbiAgICAgICAgcmVwZWF0aW5nOiByZXBlYXRpbmcsXG4gICAgICAgIHJhZGl4OiByYWRpeCxcbiAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb25cbiAgICAgIH07XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNsYXNzZXMsIGNscywgbWF0Y2gsIG5ld0NsYXNzZXMsIHRoZW1lLCBfaSwgX2xlbjtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RvcFdhdGNoaW5nTXV0YXRpb25zKCk7XG4gICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgICB0aGlzLmluc2lkZS5pbm5lckhUTUwgPSAnJztcbiAgICAgIHRoZW1lID0gdGhpcy5vcHRpb25zLnRoZW1lO1xuICAgICAgY2xhc3NlcyA9IHRoaXMuZWwuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICBuZXdDbGFzc2VzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNsYXNzZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2xzID0gY2xhc3Nlc1tfaV07XG4gICAgICAgIGlmICghY2xzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IC9eb2RvbWV0ZXItdGhlbWUtKC4rKSQvLmV4ZWMoY2xzKSkge1xuICAgICAgICAgIHRoZW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eb2RvbWV0ZXIoLXwkKS8udGVzdChjbHMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICB9XG4gICAgICBuZXdDbGFzc2VzLnB1c2goJ29kb21ldGVyJyk7XG4gICAgICBpZiAoIVRSQU5TSVRJT05fU1VQUE9SVCkge1xuICAgICAgICBuZXdDbGFzc2VzLnB1c2goJ29kb21ldGVyLW5vLXRyYW5zaXRpb25zJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhlbWUpIHtcbiAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKFwib2RvbWV0ZXItdGhlbWUtXCIgKyB0aGVtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDbGFzc2VzLnB1c2goXCJvZG9tZXRlci1hdXRvLXRoZW1lXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbC5jbGFzc05hbWUgPSBuZXdDbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgIHRoaXMucmliYm9ucyA9IHt9O1xuICAgICAgdGhpcy5mb3JtYXREaWdpdHModmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRXYXRjaGluZ011dGF0aW9ucygpO1xuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUuZm9ybWF0RGlnaXRzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBkaWdpdCwgdmFsdWVEaWdpdCwgdmFsdWVTdHJpbmcsIHdob2xlUGFydCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZiwgX3JlZjE7XG4gICAgICB0aGlzLmRpZ2l0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXRGdW5jdGlvbikge1xuICAgICAgICB2YWx1ZVN0cmluZyA9IHRoaXMub3B0aW9ucy5mb3JtYXRGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIF9yZWYgPSB2YWx1ZVN0cmluZy5zcGxpdCgnJykucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICB2YWx1ZURpZ2l0ID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKHZhbHVlRGlnaXQubWF0Y2goLzAtOS8pKSB7XG4gICAgICAgICAgICBkaWdpdCA9IHRoaXMucmVuZGVyRGlnaXQoKTtcbiAgICAgICAgICAgIGRpZ2l0LnF1ZXJ5U2VsZWN0b3IoJy5vZG9tZXRlci12YWx1ZScpLmlubmVySFRNTCA9IHZhbHVlRGlnaXQ7XG4gICAgICAgICAgICB0aGlzLmRpZ2l0cy5wdXNoKGRpZ2l0KTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RGlnaXQoZGlnaXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNwYWNlcih2YWx1ZURpZ2l0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdob2xlUGFydCA9ICF0aGlzLmZvcm1hdC5wcmVjaXNpb24gfHwgIWZyYWN0aW9uYWxQYXJ0KHZhbHVlKSB8fCBmYWxzZTtcbiAgICAgICAgX3JlZjEgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcnKS5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIGRpZ2l0ID0gX3JlZjFbX2pdO1xuICAgICAgICAgIGlmIChkaWdpdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICB3aG9sZVBhcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZERpZ2l0KGRpZ2l0LCB3aG9sZVBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgdmFyIGRpZmYsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5jbGVhblZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIGlmICghKGRpZmYgPSBuZXdWYWx1ZSAtIHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsICdvZG9tZXRlci1hbmltYXRpbmctdXAgb2RvbWV0ZXItYW5pbWF0aW5nLWRvd24gb2RvbWV0ZXItYW5pbWF0aW5nJyk7XG4gICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5lbCwgJ29kb21ldGVyLWFuaW1hdGluZy11cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5lbCwgJ29kb21ldGVyLWFuaW1hdGluZy1kb3duJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3BXYXRjaGluZ011dGF0aW9ucygpO1xuICAgICAgdGhpcy5hbmltYXRlKG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuc3RhcnRXYXRjaGluZ011dGF0aW9ucygpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICByZXR1cm4gYWRkQ2xhc3MoX3RoaXMuZWwsICdvZG9tZXRlci1hbmltYXRpbmcnKTtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnJlbmRlckRpZ2l0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJvbUhUTUwoRElHSVRfSFRNTCk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5pbnNlcnREaWdpdCA9IGZ1bmN0aW9uKGRpZ2l0LCBiZWZvcmUpIHtcbiAgICAgIGlmIChiZWZvcmUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNpZGUuaW5zZXJ0QmVmb3JlKGRpZ2l0LCBiZWZvcmUpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5pbnNpZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2lkZS5hcHBlbmRDaGlsZChkaWdpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNpZGUuaW5zZXJ0QmVmb3JlKGRpZ2l0LCB0aGlzLmluc2lkZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5hZGRTcGFjZXIgPSBmdW5jdGlvbihjaHIsIGJlZm9yZSwgZXh0cmFDbGFzc2VzKSB7XG4gICAgICB2YXIgc3BhY2VyO1xuICAgICAgc3BhY2VyID0gY3JlYXRlRnJvbUhUTUwoRk9STUFUX01BUktfSFRNTCk7XG4gICAgICBzcGFjZXIuaW5uZXJIVE1MID0gY2hyO1xuICAgICAgaWYgKGV4dHJhQ2xhc3Nlcykge1xuICAgICAgICBhZGRDbGFzcyhzcGFjZXIsIGV4dHJhQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREaWdpdChzcGFjZXIsIGJlZm9yZSk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5hZGREaWdpdCA9IGZ1bmN0aW9uKHZhbHVlLCByZXBlYXRpbmcpIHtcbiAgICAgIHZhciBjaHIsIGRpZ2l0LCByZXNldHRlZCwgX3JlZjtcbiAgICAgIGlmIChyZXBlYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICByZXBlYXRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3BhY2VyKHZhbHVlLCBudWxsLCAnb2RvbWV0ZXItbmVnYXRpb24tbWFyaycpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAnLicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3BhY2VyKChfcmVmID0gdGhpcy5mb3JtYXQucmFkaXgpICE9IG51bGwgPyBfcmVmIDogJy4nLCBudWxsLCAnb2RvbWV0ZXItcmFkaXgtbWFyaycpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGVhdGluZykge1xuICAgICAgICByZXNldHRlZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICghdGhpcy5mb3JtYXQucmVwZWF0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0dGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBvZG9tZXRlciBmb3JtYXQgd2l0aG91dCBkaWdpdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICByZXNldHRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNociA9IHRoaXMuZm9ybWF0LnJlcGVhdGluZ1t0aGlzLmZvcm1hdC5yZXBlYXRpbmcubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdGhpcy5mb3JtYXQucmVwZWF0aW5nID0gdGhpcy5mb3JtYXQucmVwZWF0aW5nLnN1YnN0cmluZygwLCB0aGlzLmZvcm1hdC5yZXBlYXRpbmcubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgaWYgKGNociA9PT0gJ2QnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZGRTcGFjZXIoY2hyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlnaXQgPSB0aGlzLnJlbmRlckRpZ2l0KCk7XG4gICAgICBkaWdpdC5xdWVyeVNlbGVjdG9yKCcub2RvbWV0ZXItdmFsdWUnKS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlnaXRzLnB1c2goZGlnaXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGlnaXQoZGlnaXQpO1xuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoIVRSQU5TSVRJT05fU1VQUE9SVCB8fCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uID09PSAnY291bnQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGVDb3VudChuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlU2xpZGUobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUuYW5pbWF0ZUNvdW50ID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgIHZhciBjdXIsIGRpZmYsIGxhc3QsIHN0YXJ0LCB0aWNrLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIShkaWZmID0gK25ld1ZhbHVlIC0gdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBsYXN0ID0gbm93KCk7XG4gICAgICBjdXIgPSB0aGlzLnZhbHVlO1xuICAgICAgcmV0dXJuICh0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWx0YSwgZGlzdCwgZnJhY3Rpb247XG4gICAgICAgIGlmICgobm93KCkgLSBzdGFydCkgPiBfdGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgX3RoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICB0cmlnZ2VyKF90aGlzLmVsLCAnb2RvbWV0ZXJkb25lJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbHRhID0gbm93KCkgLSBsYXN0O1xuICAgICAgICBpZiAoZGVsdGEgPiBDT1VOVF9NU19QRVJfRlJBTUUpIHtcbiAgICAgICAgICBsYXN0ID0gbm93KCk7XG4gICAgICAgICAgZnJhY3Rpb24gPSBkZWx0YSAvIF90aGlzLm9wdGlvbnMuZHVyYXRpb247XG4gICAgICAgICAgZGlzdCA9IGRpZmYgKiBmcmFjdGlvbjtcbiAgICAgICAgICBjdXIgKz0gZGlzdDtcbiAgICAgICAgICBfdGhpcy5yZW5kZXIoTWF0aC5yb3VuZChjdXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHRpY2ssIENPVU5UX01TX1BFUl9GUkFNRSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5nZXREaWdpdENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgbWF4LCB2YWx1ZSwgdmFsdWVzLCBfaSwgX2xlbjtcbiAgICAgIHZhbHVlcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSB2YWx1ZXMubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICB2YWx1ZXNbaV0gPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZyhtYXggKyAxKSAvIE1hdGgubG9nKDEwKSk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5nZXRGcmFjdGlvbmFsRGlnaXRDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHBhcnNlciwgcGFydHMsIHZhbHVlLCB2YWx1ZXMsIF9pLCBfbGVuO1xuICAgICAgdmFsdWVzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIHBhcnNlciA9IC9eXFwtP1xcZCpcXC4oXFxkKj8pMCokLztcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IHZhbHVlcy5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHBhcnRzID0gcGFyc2VyLmV4ZWModmFsdWVzW2ldKTtcbiAgICAgICAgaWYgKHBhcnRzID09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IHBhcnRzWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5yZXNldERpZ2l0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kaWdpdHMgPSBbXTtcbiAgICAgIHRoaXMucmliYm9ucyA9IFtdO1xuICAgICAgdGhpcy5pbnNpZGUuaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldEZvcm1hdCgpO1xuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUuYW5pbWF0ZVNsaWRlID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgIHZhciBib29zdGVkLCBjdXIsIGRpZmYsIGRpZ2l0Q291bnQsIGRpZ2l0cywgZGlzdCwgZW5kLCBmcmFjdGlvbmFsQ291bnQsIGZyYW1lLCBmcmFtZXMsIGksIGluY3IsIGosIG1hcmssIG51bUVsLCBvbGRWYWx1ZSwgc3RhcnQsIF9iYXNlLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbSwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBmcmFjdGlvbmFsQ291bnQgPSB0aGlzLmdldEZyYWN0aW9uYWxEaWdpdENvdW50KG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICBpZiAoZnJhY3Rpb25hbENvdW50KSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUgKiBNYXRoLnBvdygxMCwgZnJhY3Rpb25hbENvdW50KTtcbiAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSAqIE1hdGgucG93KDEwLCBmcmFjdGlvbmFsQ291bnQpO1xuICAgICAgfVxuICAgICAgaWYgKCEoZGlmZiA9IG5ld1ZhbHVlIC0gb2xkVmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmluZFRyYW5zaXRpb25FbmQoKTtcbiAgICAgIGRpZ2l0Q291bnQgPSB0aGlzLmdldERpZ2l0Q291bnQob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgIGRpZ2l0cyA9IFtdO1xuICAgICAgYm9vc3RlZCA9IDA7XG4gICAgICBmb3IgKGkgPSBfaSA9IDA7IDAgPD0gZGlnaXRDb3VudCA/IF9pIDwgZGlnaXRDb3VudCA6IF9pID4gZGlnaXRDb3VudDsgaSA9IDAgPD0gZGlnaXRDb3VudCA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIHN0YXJ0ID0gdHJ1bmNhdGUob2xkVmFsdWUgLyBNYXRoLnBvdygxMCwgZGlnaXRDb3VudCAtIGkgLSAxKSk7XG4gICAgICAgIGVuZCA9IHRydW5jYXRlKG5ld1ZhbHVlIC8gTWF0aC5wb3coMTAsIGRpZ2l0Q291bnQgLSBpIC0gMSkpO1xuICAgICAgICBkaXN0ID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhkaXN0KSA+IHRoaXMuTUFYX1ZBTFVFUykge1xuICAgICAgICAgIGZyYW1lcyA9IFtdO1xuICAgICAgICAgIGluY3IgPSBkaXN0IC8gKHRoaXMuTUFYX1ZBTFVFUyArIHRoaXMuTUFYX1ZBTFVFUyAqIGJvb3N0ZWQgKiBESUdJVF9TUEVFREJPT1NUKTtcbiAgICAgICAgICBjdXIgPSBzdGFydDtcbiAgICAgICAgICB3aGlsZSAoKGRpc3QgPiAwICYmIGN1ciA8IGVuZCkgfHwgKGRpc3QgPCAwICYmIGN1ciA+IGVuZCkpIHtcbiAgICAgICAgICAgIGZyYW1lcy5wdXNoKE1hdGgucm91bmQoY3VyKSk7XG4gICAgICAgICAgICBjdXIgKz0gaW5jcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0gIT09IGVuZCkge1xuICAgICAgICAgICAgZnJhbWVzLnB1c2goZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9vc3RlZCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYW1lcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IHN0YXJ0OyBzdGFydCA8PSBlbmQgPyBfaiA8PSBlbmQgOiBfaiA+PSBlbmQ7IHN0YXJ0IDw9IGVuZCA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMucHVzaChfaik7IH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KS5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBfayA9IDAsIF9sZW4gPSBmcmFtZXMubGVuZ3RoOyBfayA8IF9sZW47IGkgPSArK19rKSB7XG4gICAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICAgICAgZnJhbWVzW2ldID0gTWF0aC5hYnMoZnJhbWUgJSAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlnaXRzLnB1c2goZnJhbWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXREaWdpdHMoKTtcbiAgICAgIF9yZWYgPSBkaWdpdHMucmV2ZXJzZSgpO1xuICAgICAgZm9yIChpID0gX2wgPSAwLCBfbGVuMSA9IF9yZWYubGVuZ3RoOyBfbCA8IF9sZW4xOyBpID0gKytfbCkge1xuICAgICAgICBmcmFtZXMgPSBfcmVmW2ldO1xuICAgICAgICBpZiAoIXRoaXMuZGlnaXRzW2ldKSB7XG4gICAgICAgICAgdGhpcy5hZGREaWdpdCgnICcsIGkgPj0gZnJhY3Rpb25hbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iYXNlID0gdGhpcy5yaWJib25zKVtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgX2Jhc2VbaV0gPSB0aGlzLmRpZ2l0c1tpXS5xdWVyeVNlbGVjdG9yKCcub2RvbWV0ZXItcmliYm9uLWlubmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWJib25zW2ldLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICBmcmFtZXMgPSBmcmFtZXMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IF9tID0gMCwgX2xlbjIgPSBmcmFtZXMubGVuZ3RoOyBfbSA8IF9sZW4yOyBqID0gKytfbSkge1xuICAgICAgICAgIGZyYW1lID0gZnJhbWVzW2pdO1xuICAgICAgICAgIG51bUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgbnVtRWwuY2xhc3NOYW1lID0gJ29kb21ldGVyLXZhbHVlJztcbiAgICAgICAgICBudW1FbC5pbm5lckhUTUwgPSBmcmFtZTtcbiAgICAgICAgICB0aGlzLnJpYmJvbnNbaV0uYXBwZW5kQ2hpbGQobnVtRWwpO1xuICAgICAgICAgIGlmIChqID09PSBmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MobnVtRWwsICdvZG9tZXRlci1sYXN0LXZhbHVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhudW1FbCwgJ29kb21ldGVyLWZpcnN0LXZhbHVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHRoaXMuYWRkRGlnaXQoJy0nKTtcbiAgICAgIH1cbiAgICAgIG1hcmsgPSB0aGlzLmluc2lkZS5xdWVyeVNlbGVjdG9yKCcub2RvbWV0ZXItcmFkaXgtbWFyaycpO1xuICAgICAgaWYgKG1hcmsgIT0gbnVsbCkge1xuICAgICAgICBtYXJrLnBhcmVudC5yZW1vdmVDaGlsZChtYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFjdGlvbmFsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3BhY2VyKHRoaXMuZm9ybWF0LnJhZGl4LCB0aGlzLmRpZ2l0c1tmcmFjdGlvbmFsQ291bnQgLSAxXSwgJ29kb21ldGVyLXJhZGl4LW1hcmsnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE9kb21ldGVyO1xuXG4gIH0pKCk7XG5cbiAgT2RvbWV0ZXIub3B0aW9ucyA9IChfcmVmID0gd2luZG93Lm9kb21ldGVyT3B0aW9ucykgIT0gbnVsbCA/IF9yZWYgOiB7fTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLCB2LCBfYmFzZSwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmICh3aW5kb3cub2RvbWV0ZXJPcHRpb25zKSB7XG4gICAgICBfcmVmMSA9IHdpbmRvdy5vZG9tZXRlck9wdGlvbnM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChrIGluIF9yZWYxKSB7XG4gICAgICAgIHYgPSBfcmVmMVtrXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoX2Jhc2UgPSBPZG9tZXRlci5vcHRpb25zKVtrXSAhPSBudWxsID8gKF9iYXNlID0gT2RvbWV0ZXIub3B0aW9ucylba10gOiBfYmFzZVtrXSA9IHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH1cbiAgfSwgMCk7XG5cbiAgT2RvbWV0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbCwgZWxlbWVudHMsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoT2RvbWV0ZXIub3B0aW9ucy5zZWxlY3RvciB8fCAnLm9kb21ldGVyJyk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGVsZW1lbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbCA9IGVsZW1lbnRzW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goZWwub2RvbWV0ZXIgPSBuZXcgT2RvbWV0ZXIoe1xuICAgICAgICBlbDogZWwsXG4gICAgICAgIHZhbHVlOiAoX3JlZjEgPSBlbC5pbm5lclRleHQpICE9IG51bGwgPyBfcmVmMSA6IGVsLnRleHRDb250ZW50XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBpZiAoKCgoX3JlZjEgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpICE9IG51bGwgPyBfcmVmMS5kb1Njcm9sbCA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0ICE9IG51bGwpKSB7XG4gICAgX29sZCA9IGRvY3VtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZTtcbiAgICBkb2N1bWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnICYmIE9kb21ldGVyLm9wdGlvbnMuYXV0byAhPT0gZmFsc2UpIHtcbiAgICAgICAgT2RvbWV0ZXIuaW5pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9vbGQgIT0gbnVsbCA/IF9vbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHZvaWQgMDtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChPZG9tZXRlci5vcHRpb25zLmF1dG8gIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBPZG9tZXRlci5pbml0KCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2RvbWV0ZXI7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgZXhwb3J0cyAhPT0gbnVsbCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gT2RvbWV0ZXI7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93Lk9kb21ldGVyID0gT2RvbWV0ZXI7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/odometer/odometer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-odometerjs/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-odometerjs/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var odometer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! odometer */ \"(app-pages-browser)/./node_modules/odometer/odometer.js\");\n/* harmony import */ var odometer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(odometer__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst ReactOdometer = ({ animation, duration, format, theme, value, ...rest }) => {\n    const node = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const odometer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        odometer.current = new (odometer__WEBPACK_IMPORTED_MODULE_1___default())({\n            el: node.current,\n            auto: false,\n            animation,\n            duration,\n            format,\n            theme,\n            value,\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        odometer.current?.update(value);\n    }, [value]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n        ...rest,\n        ref: node,\n    });\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReactOdometer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1vZG9tZXRlcmpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUQ7QUFDekI7QUFDaEMseUJBQXlCLG9EQUFvRDtBQUM3RSxpQkFBaUIsNkNBQU07QUFDdkIscUJBQXFCLDZDQUFNO0FBQzNCLElBQUksZ0RBQVM7QUFDYiwrQkFBK0IsaURBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCxXQUFXLG9EQUFhO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrREFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW9kb21ldGVyanMvZGlzdC9pbmRleC5qcz9lMWI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE9kb21ldGVyIGZyb20gJ29kb21ldGVyJztcbmNvbnN0IFJlYWN0T2RvbWV0ZXIgPSAoeyBhbmltYXRpb24sIGR1cmF0aW9uLCBmb3JtYXQsIHRoZW1lLCB2YWx1ZSwgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvZG9tZXRlciA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9kb21ldGVyLmN1cnJlbnQgPSBuZXcgT2RvbWV0ZXIoe1xuICAgICAgICAgICAgZWw6IG5vZGUuY3VycmVudCxcbiAgICAgICAgICAgIGF1dG86IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb2RvbWV0ZXIuY3VycmVudD8udXBkYXRlKHZhbHVlKTtcbiAgICB9LCBbdmFsdWVdKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWY6IG5vZGUsXG4gICAgfSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgUmVhY3RPZG9tZXRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-odometerjs/dist/index.js\n"));

/***/ })

}]);