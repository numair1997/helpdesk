"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-animate-height";
exports.ids = ["vendor-chunks/react-animate-height"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-animate-height/dist/esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-animate-height/dist/esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// ------------------ Helpers\nfunction isNumber(n) {\n    const number = parseFloat(n);\n    return !isNaN(number) && isFinite(number);\n}\nfunction isPercentage(height) {\n    // Percentage height\n    return (typeof height === 'string' &&\n        height[height.length - 1] === '%' &&\n        isNumber(height.substring(0, height.length - 1)));\n}\nfunction hideContent(element, height, disableDisplayNone) {\n    // Check for element?.style is added cause this would fail in tests (react-test-renderer)\n    // Read more here: https://github.com/Stanko/react-animate-height/issues/17\n    if (height === 0 &&\n        !disableDisplayNone &&\n        (element === null || element === void 0 ? void 0 : element.style) &&\n        (element === null || element === void 0 ? void 0 : element.children.length) > 0) {\n        element.style.display = 'none';\n    }\n}\nfunction showContent(element, height) {\n    // Check for element?.style is added cause this would fail in tests (react-test-renderer)\n    // Read more here: https://github.com/Stanko/react-animate-height/issues/17\n    if (height === 0 && (element === null || element === void 0 ? void 0 : element.style)) {\n        element.style.display = '';\n    }\n}\nconst ANIMATION_STATE_CLASSES = {\n    animating: 'rah-animating',\n    animatingUp: 'rah-animating--up',\n    animatingDown: 'rah-animating--down',\n    animatingToHeightZero: 'rah-animating--to-height-zero',\n    animatingToHeightAuto: 'rah-animating--to-height-auto',\n    animatingToHeightSpecific: 'rah-animating--to-height-specific',\n    static: 'rah-static',\n    staticHeightZero: 'rah-static--height-zero',\n    staticHeightAuto: 'rah-static--height-auto',\n    staticHeightSpecific: 'rah-static--height-specific',\n};\nfunction getStaticStateClasses(animationStateClasses, height) {\n    return [\n        animationStateClasses.static,\n        height === 0 && animationStateClasses.staticHeightZero,\n        typeof height === 'number' && height > 0\n            ? animationStateClasses.staticHeightSpecific\n            : null,\n        height === 'auto' && animationStateClasses.staticHeightAuto,\n    ]\n        .filter((v) => v)\n        .join(' ');\n}\n// ------------------ Component\nconst propsToOmitFromDiv = [\n    'animateOpacity',\n    'animationStateClasses',\n    'applyInlineTransitions',\n    'children',\n    'className',\n    'contentClassName',\n    'contentRef',\n    'delay',\n    'duration',\n    'easing',\n    'height',\n    'onHeightAnimationEnd',\n    'onHeightAnimationStart',\n    'style',\n    'disableDisplayNone',\n];\nconst AnimateHeight = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((componentProps, ref) => {\n    // const AnimateHeight = forwardRef((componentProps: AnimateHeightProps, ref) => {\n    // const AnimateHeight: React.FC<AnimateHeightProps> = (componentProps) => {\n    const { animateOpacity = false, animationStateClasses = {}, applyInlineTransitions = true, children, className = '', contentClassName, delay: userDelay = 0, disableDisplayNone = false, duration: userDuration = 500, easing = 'ease', height, onHeightAnimationEnd, onHeightAnimationStart, style, contentRef, } = componentProps;\n    const divProps = Object.assign({}, componentProps);\n    propsToOmitFromDiv.forEach((propKey) => {\n        delete divProps[propKey];\n    });\n    // ------------------ Initialization\n    const prevHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(height);\n    const contentElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const animationClassesTimeoutID = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const timeoutID = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const stateClasses = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Object.assign(Object.assign({}, ANIMATION_STATE_CLASSES), animationStateClasses));\n    const isBrowser = typeof window !== 'undefined';\n    const prefersReducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isBrowser && window.matchMedia\n        ? window.matchMedia('(prefers-reduced-motion)').matches\n        : false);\n    const delay = prefersReducedMotion.current ? 0 : userDelay;\n    const duration = prefersReducedMotion.current ? 0 : userDuration;\n    let initHeight = height;\n    let initOverflow = 'visible';\n    if (typeof height === 'number') {\n        // Reset negative height to 0\n        initHeight = height < 0 ? 0 : height;\n        initOverflow = 'hidden';\n    }\n    else if (isPercentage(initHeight)) {\n        // If value is string \"0%\" make sure we convert it to number 0\n        initHeight = height === '0%' ? 0 : height;\n        initOverflow = 'hidden';\n    }\n    const [currentHeight, setCurrentHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initHeight);\n    const [overflow, setOverflow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initOverflow);\n    const [useTransitions, setUseTransitions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [animationStateClassNames, setAnimationStateClassNames] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getStaticStateClasses(stateClasses.current, height));\n    // ------------------ Did mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        // Hide content if height is 0 (to prevent tabbing into it)\n        hideContent(contentElement.current, currentHeight, disableDisplayNone);\n        // This should be explicitly run only on mount\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // ------------------ Height update\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (height !== prevHeight.current && contentElement.current) {\n            showContent(contentElement.current, prevHeight.current);\n            // Cache content height\n            contentElement.current.style.overflow = 'hidden';\n            const contentHeight = contentElement.current.offsetHeight;\n            contentElement.current.style.overflow = '';\n            // set total animation time\n            const totalDuration = duration + delay;\n            let newHeight;\n            let timeoutHeight;\n            let timeoutOverflow = 'hidden';\n            let timeoutUseTransitions;\n            const isCurrentHeightAuto = prevHeight.current === 'auto';\n            if (typeof height === 'number') {\n                // Reset negative height to 0\n                newHeight = height < 0 ? 0 : height;\n                timeoutHeight = newHeight;\n            }\n            else if (isPercentage(height)) {\n                // If value is string \"0%\" make sure we convert it to number 0\n                newHeight = height === '0%' ? 0 : height;\n                timeoutHeight = newHeight;\n            }\n            else {\n                // If not, animate to content height\n                // and then reset to auto\n                newHeight = contentHeight; // TODO solve contentHeight = 0\n                timeoutHeight = 'auto';\n                timeoutOverflow = undefined;\n            }\n            if (isCurrentHeightAuto) {\n                // This is the height to be animated to\n                timeoutHeight = newHeight;\n                // If previous height was 'auto'\n                // set starting height explicitly to be able to use transition\n                newHeight = contentHeight;\n            }\n            // Animation classes\n            const newAnimationStateClassNames = [\n                stateClasses.current.animating,\n                (prevHeight.current === 'auto' || height < prevHeight.current) &&\n                    stateClasses.current.animatingUp,\n                (height === 'auto' || height > prevHeight.current) &&\n                    stateClasses.current.animatingDown,\n                timeoutHeight === 0 && stateClasses.current.animatingToHeightZero,\n                timeoutHeight === 'auto' &&\n                    stateClasses.current.animatingToHeightAuto,\n                typeof timeoutHeight === 'number' && timeoutHeight > 0\n                    ? stateClasses.current.animatingToHeightSpecific\n                    : null,\n            ]\n                .filter((v) => v)\n                .join(' ');\n            // Animation classes to be put after animation is complete\n            const timeoutAnimationStateClasses = getStaticStateClasses(stateClasses.current, timeoutHeight);\n            // Set starting height and animating classes\n            // When animating from 'auto' we first need to set fixed height\n            // that change should be animated\n            setCurrentHeight(newHeight);\n            setOverflow('hidden');\n            setUseTransitions(!isCurrentHeightAuto);\n            setAnimationStateClassNames(newAnimationStateClassNames);\n            // Clear timeouts\n            clearTimeout(timeoutID.current);\n            clearTimeout(animationClassesTimeoutID.current);\n            if (isCurrentHeightAuto) {\n                // When animating from 'auto' we use a short timeout to start animation\n                // after setting fixed height above\n                timeoutUseTransitions = true;\n                // Short timeout to allow rendering of the initial animation state first\n                timeoutID.current = setTimeout(() => {\n                    setCurrentHeight(timeoutHeight);\n                    setOverflow(timeoutOverflow);\n                    setUseTransitions(timeoutUseTransitions);\n                    // ANIMATION STARTS, run a callback if it exists\n                    onHeightAnimationStart === null || onHeightAnimationStart === void 0 ? void 0 : onHeightAnimationStart(timeoutHeight);\n                }, 50);\n                // Set static classes and remove transitions when animation ends\n                animationClassesTimeoutID.current = setTimeout(() => {\n                    setUseTransitions(false);\n                    setAnimationStateClassNames(timeoutAnimationStateClasses);\n                    // ANIMATION ENDS\n                    // Hide content if height is 0 (to prevent tabbing into it)\n                    hideContent(contentElement.current, timeoutHeight, disableDisplayNone);\n                    // Run a callback if it exists\n                    onHeightAnimationEnd === null || onHeightAnimationEnd === void 0 ? void 0 : onHeightAnimationEnd(timeoutHeight);\n                }, totalDuration);\n            }\n            else {\n                // ANIMATION STARTS, run a callback if it exists\n                onHeightAnimationStart === null || onHeightAnimationStart === void 0 ? void 0 : onHeightAnimationStart(newHeight);\n                // Set end height, classes and remove transitions when animation is complete\n                timeoutID.current = setTimeout(() => {\n                    setCurrentHeight(timeoutHeight);\n                    setOverflow(timeoutOverflow);\n                    setUseTransitions(false);\n                    setAnimationStateClassNames(timeoutAnimationStateClasses);\n                    // ANIMATION ENDS\n                    // If height is auto, don't hide the content\n                    // (case when element is empty, therefore height is 0)\n                    if (height !== 'auto') {\n                        // Hide content if height is 0 (to prevent tabbing into it)\n                        hideContent(contentElement.current, newHeight, disableDisplayNone); // TODO solve newHeight = 0\n                    }\n                    // Run a callback if it exists\n                    onHeightAnimationEnd === null || onHeightAnimationEnd === void 0 ? void 0 : onHeightAnimationEnd(newHeight);\n                }, totalDuration);\n            }\n        }\n        prevHeight.current = height;\n        return () => {\n            clearTimeout(timeoutID.current);\n            clearTimeout(animationClassesTimeoutID.current);\n        };\n        // This should be explicitly run only on height change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [height]);\n    // ------------------ Render\n    const componentStyle = Object.assign(Object.assign({}, style), { height: currentHeight, overflow: overflow || (style === null || style === void 0 ? void 0 : style.overflow) });\n    if (useTransitions && applyInlineTransitions) {\n        componentStyle.transition = `height ${duration}ms ${easing} ${delay}ms`;\n        // Include transition passed through styles\n        if (style === null || style === void 0 ? void 0 : style.transition) {\n            componentStyle.transition = `${style.transition}, ${componentStyle.transition}`;\n        }\n        // Add webkit vendor prefix still used by opera, blackberry...\n        componentStyle.WebkitTransition = componentStyle.transition;\n    }\n    const contentStyle = {};\n    if (animateOpacity) {\n        contentStyle.transition = `opacity ${duration}ms ${easing} ${delay}ms`;\n        // Add webkit vendor prefix still used by opera, blackberry...\n        contentStyle.WebkitTransition = contentStyle.transition;\n        if (currentHeight === 0) {\n            contentStyle.opacity = 0;\n        }\n    }\n    // Check if user passed aria-hidden prop\n    const hasAriaHiddenProp = typeof divProps['aria-hidden'] !== 'undefined';\n    const ariaHidden = hasAriaHiddenProp\n        ? divProps['aria-hidden']\n        : height === 0;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({}, divProps, { \"aria-hidden\": ariaHidden, className: `${animationStateClassNames} ${className}`, style: componentStyle, ref: ref }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: contentClassName, style: contentStyle, ref: (el) => {\n                contentElement.current = el;\n                if (contentRef) {\n                    contentRef.current = el;\n                }\n            } }, children)));\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnimateHeight);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYW5pbWF0ZS1oZWlnaHQvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQWdCO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZLGtEQUFrRCx5UEFBeVA7QUFDdlQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUIsNkNBQU07QUFDN0IsMkJBQTJCLDZDQUFNO0FBQ2pDLHNDQUFzQyw2Q0FBTTtBQUM1QyxzQkFBc0IsNkNBQU07QUFDNUIseUJBQXlCLDZDQUFNLCtCQUErQjtBQUM5RDtBQUNBLGlDQUFpQyw2Q0FBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQ0FBUTtBQUN0RCxvQ0FBb0MsK0NBQVE7QUFDNUMsZ0RBQWdELCtDQUFRO0FBQ3hELG9FQUFvRSwrQ0FBUTtBQUM1RTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RCxZQUFZLDZHQUE2RztBQUNsTDtBQUNBLDhDQUE4QyxTQUFTLEtBQUssUUFBUSxFQUFFLE1BQU07QUFDNUU7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUIsSUFBSSwwQkFBMEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsS0FBSyxRQUFRLEVBQUUsTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBbUIsd0JBQXdCLGNBQWMseUNBQXlDLDBCQUEwQixFQUFFLFVBQVUsb0NBQW9DO0FBQ3hMLFFBQVEsZ0RBQW1CLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsQ0FBQztBQUNELGlFQUFlLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlcnZpYmUtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWFuaW1hdGUtaGVpZ2h0L2Rpc3QvZXNtL2luZGV4LmpzP2MwOGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0Jztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLSBIZWxwZXJzXG5mdW5jdGlvbiBpc051bWJlcihuKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcGFyc2VGbG9hdChuKTtcbiAgICByZXR1cm4gIWlzTmFOKG51bWJlcikgJiYgaXNGaW5pdGUobnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGlzUGVyY2VudGFnZShoZWlnaHQpIHtcbiAgICAvLyBQZXJjZW50YWdlIGhlaWdodFxuICAgIHJldHVybiAodHlwZW9mIGhlaWdodCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgaGVpZ2h0W2hlaWdodC5sZW5ndGggLSAxXSA9PT0gJyUnICYmXG4gICAgICAgIGlzTnVtYmVyKGhlaWdodC5zdWJzdHJpbmcoMCwgaGVpZ2h0Lmxlbmd0aCAtIDEpKSk7XG59XG5mdW5jdGlvbiBoaWRlQ29udGVudChlbGVtZW50LCBoZWlnaHQsIGRpc2FibGVEaXNwbGF5Tm9uZSkge1xuICAgIC8vIENoZWNrIGZvciBlbGVtZW50Py5zdHlsZSBpcyBhZGRlZCBjYXVzZSB0aGlzIHdvdWxkIGZhaWwgaW4gdGVzdHMgKHJlYWN0LXRlc3QtcmVuZGVyZXIpXG4gICAgLy8gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFua28vcmVhY3QtYW5pbWF0ZS1oZWlnaHQvaXNzdWVzLzE3XG4gICAgaWYgKGhlaWdodCA9PT0gMCAmJlxuICAgICAgICAhZGlzYWJsZURpc3BsYXlOb25lICYmXG4gICAgICAgIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuc3R5bGUpICYmXG4gICAgICAgIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3dDb250ZW50KGVsZW1lbnQsIGhlaWdodCkge1xuICAgIC8vIENoZWNrIGZvciBlbGVtZW50Py5zdHlsZSBpcyBhZGRlZCBjYXVzZSB0aGlzIHdvdWxkIGZhaWwgaW4gdGVzdHMgKHJlYWN0LXRlc3QtcmVuZGVyZXIpXG4gICAgLy8gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFua28vcmVhY3QtYW5pbWF0ZS1oZWlnaHQvaXNzdWVzLzE3XG4gICAgaWYgKGhlaWdodCA9PT0gMCAmJiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnN0eWxlKSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG59XG5jb25zdCBBTklNQVRJT05fU1RBVEVfQ0xBU1NFUyA9IHtcbiAgICBhbmltYXRpbmc6ICdyYWgtYW5pbWF0aW5nJyxcbiAgICBhbmltYXRpbmdVcDogJ3JhaC1hbmltYXRpbmctLXVwJyxcbiAgICBhbmltYXRpbmdEb3duOiAncmFoLWFuaW1hdGluZy0tZG93bicsXG4gICAgYW5pbWF0aW5nVG9IZWlnaHRaZXJvOiAncmFoLWFuaW1hdGluZy0tdG8taGVpZ2h0LXplcm8nLFxuICAgIGFuaW1hdGluZ1RvSGVpZ2h0QXV0bzogJ3JhaC1hbmltYXRpbmctLXRvLWhlaWdodC1hdXRvJyxcbiAgICBhbmltYXRpbmdUb0hlaWdodFNwZWNpZmljOiAncmFoLWFuaW1hdGluZy0tdG8taGVpZ2h0LXNwZWNpZmljJyxcbiAgICBzdGF0aWM6ICdyYWgtc3RhdGljJyxcbiAgICBzdGF0aWNIZWlnaHRaZXJvOiAncmFoLXN0YXRpYy0taGVpZ2h0LXplcm8nLFxuICAgIHN0YXRpY0hlaWdodEF1dG86ICdyYWgtc3RhdGljLS1oZWlnaHQtYXV0bycsXG4gICAgc3RhdGljSGVpZ2h0U3BlY2lmaWM6ICdyYWgtc3RhdGljLS1oZWlnaHQtc3BlY2lmaWMnLFxufTtcbmZ1bmN0aW9uIGdldFN0YXRpY1N0YXRlQ2xhc3NlcyhhbmltYXRpb25TdGF0ZUNsYXNzZXMsIGhlaWdodCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGFuaW1hdGlvblN0YXRlQ2xhc3Nlcy5zdGF0aWMsXG4gICAgICAgIGhlaWdodCA9PT0gMCAmJiBhbmltYXRpb25TdGF0ZUNsYXNzZXMuc3RhdGljSGVpZ2h0WmVybyxcbiAgICAgICAgdHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicgJiYgaGVpZ2h0ID4gMFxuICAgICAgICAgICAgPyBhbmltYXRpb25TdGF0ZUNsYXNzZXMuc3RhdGljSGVpZ2h0U3BlY2lmaWNcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgaGVpZ2h0ID09PSAnYXV0bycgJiYgYW5pbWF0aW9uU3RhdGVDbGFzc2VzLnN0YXRpY0hlaWdodEF1dG8sXG4gICAgXVxuICAgICAgICAuZmlsdGVyKCh2KSA9PiB2KVxuICAgICAgICAuam9pbignICcpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tIENvbXBvbmVudFxuY29uc3QgcHJvcHNUb09taXRGcm9tRGl2ID0gW1xuICAgICdhbmltYXRlT3BhY2l0eScsXG4gICAgJ2FuaW1hdGlvblN0YXRlQ2xhc3NlcycsXG4gICAgJ2FwcGx5SW5saW5lVHJhbnNpdGlvbnMnLFxuICAgICdjaGlsZHJlbicsXG4gICAgJ2NsYXNzTmFtZScsXG4gICAgJ2NvbnRlbnRDbGFzc05hbWUnLFxuICAgICdjb250ZW50UmVmJyxcbiAgICAnZGVsYXknLFxuICAgICdkdXJhdGlvbicsXG4gICAgJ2Vhc2luZycsXG4gICAgJ2hlaWdodCcsXG4gICAgJ29uSGVpZ2h0QW5pbWF0aW9uRW5kJyxcbiAgICAnb25IZWlnaHRBbmltYXRpb25TdGFydCcsXG4gICAgJ3N0eWxlJyxcbiAgICAnZGlzYWJsZURpc3BsYXlOb25lJyxcbl07XG5jb25zdCBBbmltYXRlSGVpZ2h0ID0gUmVhY3QuZm9yd2FyZFJlZigoY29tcG9uZW50UHJvcHMsIHJlZikgPT4ge1xuICAgIC8vIGNvbnN0IEFuaW1hdGVIZWlnaHQgPSBmb3J3YXJkUmVmKChjb21wb25lbnRQcm9wczogQW5pbWF0ZUhlaWdodFByb3BzLCByZWYpID0+IHtcbiAgICAvLyBjb25zdCBBbmltYXRlSGVpZ2h0OiBSZWFjdC5GQzxBbmltYXRlSGVpZ2h0UHJvcHM+ID0gKGNvbXBvbmVudFByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBhbmltYXRlT3BhY2l0eSA9IGZhbHNlLCBhbmltYXRpb25TdGF0ZUNsYXNzZXMgPSB7fSwgYXBwbHlJbmxpbmVUcmFuc2l0aW9ucyA9IHRydWUsIGNoaWxkcmVuLCBjbGFzc05hbWUgPSAnJywgY29udGVudENsYXNzTmFtZSwgZGVsYXk6IHVzZXJEZWxheSA9IDAsIGRpc2FibGVEaXNwbGF5Tm9uZSA9IGZhbHNlLCBkdXJhdGlvbjogdXNlckR1cmF0aW9uID0gNTAwLCBlYXNpbmcgPSAnZWFzZScsIGhlaWdodCwgb25IZWlnaHRBbmltYXRpb25FbmQsIG9uSGVpZ2h0QW5pbWF0aW9uU3RhcnQsIHN0eWxlLCBjb250ZW50UmVmLCB9ID0gY29tcG9uZW50UHJvcHM7XG4gICAgY29uc3QgZGl2UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBjb21wb25lbnRQcm9wcyk7XG4gICAgcHJvcHNUb09taXRGcm9tRGl2LmZvckVhY2goKHByb3BLZXkpID0+IHtcbiAgICAgICAgZGVsZXRlIGRpdlByb3BzW3Byb3BLZXldO1xuICAgIH0pO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLSBJbml0aWFsaXphdGlvblxuICAgIGNvbnN0IHByZXZIZWlnaHQgPSB1c2VSZWYoaGVpZ2h0KTtcbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBhbmltYXRpb25DbGFzc2VzVGltZW91dElEID0gdXNlUmVmKCk7XG4gICAgY29uc3QgdGltZW91dElEID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc3RhdGVDbGFzc2VzID0gdXNlUmVmKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQU5JTUFUSU9OX1NUQVRFX0NMQVNTRVMpLCBhbmltYXRpb25TdGF0ZUNsYXNzZXMpKTtcbiAgICBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICBjb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHVzZVJlZihpc0Jyb3dzZXIgJiYgd2luZG93Lm1hdGNoTWVkaWFcbiAgICAgICAgPyB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pJykubWF0Y2hlc1xuICAgICAgICA6IGZhbHNlKTtcbiAgICBjb25zdCBkZWxheSA9IHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPyAwIDogdXNlckRlbGF5O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCA/IDAgOiB1c2VyRHVyYXRpb247XG4gICAgbGV0IGluaXRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IGluaXRPdmVyZmxvdyA9ICd2aXNpYmxlJztcbiAgICBpZiAodHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gUmVzZXQgbmVnYXRpdmUgaGVpZ2h0IHRvIDBcbiAgICAgICAgaW5pdEhlaWdodCA9IGhlaWdodCA8IDAgPyAwIDogaGVpZ2h0O1xuICAgICAgICBpbml0T3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQZXJjZW50YWdlKGluaXRIZWlnaHQpKSB7XG4gICAgICAgIC8vIElmIHZhbHVlIGlzIHN0cmluZyBcIjAlXCIgbWFrZSBzdXJlIHdlIGNvbnZlcnQgaXQgdG8gbnVtYmVyIDBcbiAgICAgICAgaW5pdEhlaWdodCA9IGhlaWdodCA9PT0gJzAlJyA/IDAgOiBoZWlnaHQ7XG4gICAgICAgIGluaXRPdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICBjb25zdCBbY3VycmVudEhlaWdodCwgc2V0Q3VycmVudEhlaWdodF0gPSB1c2VTdGF0ZShpbml0SGVpZ2h0KTtcbiAgICBjb25zdCBbb3ZlcmZsb3csIHNldE92ZXJmbG93XSA9IHVzZVN0YXRlKGluaXRPdmVyZmxvdyk7XG4gICAgY29uc3QgW3VzZVRyYW5zaXRpb25zLCBzZXRVc2VUcmFuc2l0aW9uc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2FuaW1hdGlvblN0YXRlQ2xhc3NOYW1lcywgc2V0QW5pbWF0aW9uU3RhdGVDbGFzc05hbWVzXSA9IHVzZVN0YXRlKGdldFN0YXRpY1N0YXRlQ2xhc3NlcyhzdGF0ZUNsYXNzZXMuY3VycmVudCwgaGVpZ2h0KSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tIERpZCBtb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEhpZGUgY29udGVudCBpZiBoZWlnaHQgaXMgMCAodG8gcHJldmVudCB0YWJiaW5nIGludG8gaXQpXG4gICAgICAgIGhpZGVDb250ZW50KGNvbnRlbnRFbGVtZW50LmN1cnJlbnQsIGN1cnJlbnRIZWlnaHQsIGRpc2FibGVEaXNwbGF5Tm9uZSk7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGV4cGxpY2l0bHkgcnVuIG9ubHkgb24gbW91bnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtdKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0gSGVpZ2h0IHVwZGF0ZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChoZWlnaHQgIT09IHByZXZIZWlnaHQuY3VycmVudCAmJiBjb250ZW50RWxlbWVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICBzaG93Q29udGVudChjb250ZW50RWxlbWVudC5jdXJyZW50LCBwcmV2SGVpZ2h0LmN1cnJlbnQpO1xuICAgICAgICAgICAgLy8gQ2FjaGUgY29udGVudCBoZWlnaHRcbiAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LmN1cnJlbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRIZWlnaHQgPSBjb250ZW50RWxlbWVudC5jdXJyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LmN1cnJlbnQuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgICAgIC8vIHNldCB0b3RhbCBhbmltYXRpb24gdGltZVxuICAgICAgICAgICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IGR1cmF0aW9uICsgZGVsYXk7XG4gICAgICAgICAgICBsZXQgbmV3SGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgdGltZW91dE92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBsZXQgdGltZW91dFVzZVRyYW5zaXRpb25zO1xuICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50SGVpZ2h0QXV0byA9IHByZXZIZWlnaHQuY3VycmVudCA9PT0gJ2F1dG8nO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgbmVnYXRpdmUgaGVpZ2h0IHRvIDBcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBoZWlnaHQgPCAwID8gMCA6IGhlaWdodDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQZXJjZW50YWdlKGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBzdHJpbmcgXCIwJVwiIG1ha2Ugc3VyZSB3ZSBjb252ZXJ0IGl0IHRvIG51bWJlciAwXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gaGVpZ2h0ID09PSAnMCUnID8gMCA6IGhlaWdodDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90LCBhbmltYXRlIHRvIGNvbnRlbnQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gcmVzZXQgdG8gYXV0b1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IGNvbnRlbnRIZWlnaHQ7IC8vIFRPRE8gc29sdmUgY29udGVudEhlaWdodCA9IDBcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHRpbWVvdXRPdmVyZmxvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0N1cnJlbnRIZWlnaHRBdXRvKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaGVpZ2h0IHRvIGJlIGFuaW1hdGVkIHRvXG4gICAgICAgICAgICAgICAgdGltZW91dEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBoZWlnaHQgd2FzICdhdXRvJ1xuICAgICAgICAgICAgICAgIC8vIHNldCBzdGFydGluZyBoZWlnaHQgZXhwbGljaXRseSB0byBiZSBhYmxlIHRvIHVzZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gY29udGVudEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBjbGFzc2VzXG4gICAgICAgICAgICBjb25zdCBuZXdBbmltYXRpb25TdGF0ZUNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgc3RhdGVDbGFzc2VzLmN1cnJlbnQuYW5pbWF0aW5nLFxuICAgICAgICAgICAgICAgIChwcmV2SGVpZ2h0LmN1cnJlbnQgPT09ICdhdXRvJyB8fCBoZWlnaHQgPCBwcmV2SGVpZ2h0LmN1cnJlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ2xhc3Nlcy5jdXJyZW50LmFuaW1hdGluZ1VwLFxuICAgICAgICAgICAgICAgIChoZWlnaHQgPT09ICdhdXRvJyB8fCBoZWlnaHQgPiBwcmV2SGVpZ2h0LmN1cnJlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ2xhc3Nlcy5jdXJyZW50LmFuaW1hdGluZ0Rvd24sXG4gICAgICAgICAgICAgICAgdGltZW91dEhlaWdodCA9PT0gMCAmJiBzdGF0ZUNsYXNzZXMuY3VycmVudC5hbmltYXRpbmdUb0hlaWdodFplcm8sXG4gICAgICAgICAgICAgICAgdGltZW91dEhlaWdodCA9PT0gJ2F1dG8nICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ2xhc3Nlcy5jdXJyZW50LmFuaW1hdGluZ1RvSGVpZ2h0QXV0byxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGltZW91dEhlaWdodCA9PT0gJ251bWJlcicgJiYgdGltZW91dEhlaWdodCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0ZUNsYXNzZXMuY3VycmVudC5hbmltYXRpbmdUb0hlaWdodFNwZWNpZmljXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiB2KVxuICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICAvLyBBbmltYXRpb24gY2xhc3NlcyB0byBiZSBwdXQgYWZ0ZXIgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0QW5pbWF0aW9uU3RhdGVDbGFzc2VzID0gZ2V0U3RhdGljU3RhdGVDbGFzc2VzKHN0YXRlQ2xhc3Nlcy5jdXJyZW50LCB0aW1lb3V0SGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIFNldCBzdGFydGluZyBoZWlnaHQgYW5kIGFuaW1hdGluZyBjbGFzc2VzXG4gICAgICAgICAgICAvLyBXaGVuIGFuaW1hdGluZyBmcm9tICdhdXRvJyB3ZSBmaXJzdCBuZWVkIHRvIHNldCBmaXhlZCBoZWlnaHRcbiAgICAgICAgICAgIC8vIHRoYXQgY2hhbmdlIHNob3VsZCBiZSBhbmltYXRlZFxuICAgICAgICAgICAgc2V0Q3VycmVudEhlaWdodChuZXdIZWlnaHQpO1xuICAgICAgICAgICAgc2V0T3ZlcmZsb3coJ2hpZGRlbicpO1xuICAgICAgICAgICAgc2V0VXNlVHJhbnNpdGlvbnMoIWlzQ3VycmVudEhlaWdodEF1dG8pO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uU3RhdGVDbGFzc05hbWVzKG5ld0FuaW1hdGlvblN0YXRlQ2xhc3NOYW1lcyk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0c1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DbGFzc2VzVGltZW91dElELmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGlzQ3VycmVudEhlaWdodEF1dG8pIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFuaW1hdGluZyBmcm9tICdhdXRvJyB3ZSB1c2UgYSBzaG9ydCB0aW1lb3V0IHRvIHN0YXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHNldHRpbmcgZml4ZWQgaGVpZ2h0IGFib3ZlXG4gICAgICAgICAgICAgICAgdGltZW91dFVzZVRyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBTaG9ydCB0aW1lb3V0IHRvIGFsbG93IHJlbmRlcmluZyBvZiB0aGUgaW5pdGlhbCBhbmltYXRpb24gc3RhdGUgZmlyc3RcbiAgICAgICAgICAgICAgICB0aW1lb3V0SUQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50SGVpZ2h0KHRpbWVvdXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRPdmVyZmxvdyh0aW1lb3V0T3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgICAgICBzZXRVc2VUcmFuc2l0aW9ucyh0aW1lb3V0VXNlVHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBTklNQVRJT04gU1RBUlRTLCBydW4gYSBjYWxsYmFjayBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgb25IZWlnaHRBbmltYXRpb25TdGFydCA9PT0gbnVsbCB8fCBvbkhlaWdodEFuaW1hdGlvblN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkhlaWdodEFuaW1hdGlvblN0YXJ0KHRpbWVvdXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgc3RhdGljIGNsYXNzZXMgYW5kIHJlbW92ZSB0cmFuc2l0aW9ucyB3aGVuIGFuaW1hdGlvbiBlbmRzXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2xhc3Nlc1RpbWVvdXRJRC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFVzZVRyYW5zaXRpb25zKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uU3RhdGVDbGFzc05hbWVzKHRpbWVvdXRBbmltYXRpb25TdGF0ZUNsYXNzZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBTklNQVRJT04gRU5EU1xuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGNvbnRlbnQgaWYgaGVpZ2h0IGlzIDAgKHRvIHByZXZlbnQgdGFiYmluZyBpbnRvIGl0KVxuICAgICAgICAgICAgICAgICAgICBoaWRlQ29udGVudChjb250ZW50RWxlbWVudC5jdXJyZW50LCB0aW1lb3V0SGVpZ2h0LCBkaXNhYmxlRGlzcGxheU5vbmUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gYSBjYWxsYmFjayBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgb25IZWlnaHRBbmltYXRpb25FbmQgPT09IG51bGwgfHwgb25IZWlnaHRBbmltYXRpb25FbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uSGVpZ2h0QW5pbWF0aW9uRW5kKHRpbWVvdXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0sIHRvdGFsRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQU5JTUFUSU9OIFNUQVJUUywgcnVuIGEgY2FsbGJhY2sgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgb25IZWlnaHRBbmltYXRpb25TdGFydCA9PT0gbnVsbCB8fCBvbkhlaWdodEFuaW1hdGlvblN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkhlaWdodEFuaW1hdGlvblN0YXJ0KG5ld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGVuZCBoZWlnaHQsIGNsYXNzZXMgYW5kIHJlbW92ZSB0cmFuc2l0aW9ucyB3aGVuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRIZWlnaHQodGltZW91dEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHNldE92ZXJmbG93KHRpbWVvdXRPdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFVzZVRyYW5zaXRpb25zKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uU3RhdGVDbGFzc05hbWVzKHRpbWVvdXRBbmltYXRpb25TdGF0ZUNsYXNzZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBTklNQVRJT04gRU5EU1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBoZWlnaHQgaXMgYXV0bywgZG9uJ3QgaGlkZSB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAvLyAoY2FzZSB3aGVuIGVsZW1lbnQgaXMgZW1wdHksIHRoZXJlZm9yZSBoZWlnaHQgaXMgMClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGNvbnRlbnQgaWYgaGVpZ2h0IGlzIDAgKHRvIHByZXZlbnQgdGFiYmluZyBpbnRvIGl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZUNvbnRlbnQoY29udGVudEVsZW1lbnQuY3VycmVudCwgbmV3SGVpZ2h0LCBkaXNhYmxlRGlzcGxheU5vbmUpOyAvLyBUT0RPIHNvbHZlIG5ld0hlaWdodCA9IDBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gYSBjYWxsYmFjayBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgb25IZWlnaHRBbmltYXRpb25FbmQgPT09IG51bGwgfHwgb25IZWlnaHRBbmltYXRpb25FbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uSGVpZ2h0QW5pbWF0aW9uRW5kKG5ld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfSwgdG90YWxEdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldkhlaWdodC5jdXJyZW50ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DbGFzc2VzVGltZW91dElELmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBleHBsaWNpdGx5IHJ1biBvbmx5IG9uIGhlaWdodCBjaGFuZ2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtoZWlnaHRdKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0gUmVuZGVyXG4gICAgY29uc3QgY29tcG9uZW50U3R5bGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlKSwgeyBoZWlnaHQ6IGN1cnJlbnRIZWlnaHQsIG92ZXJmbG93OiBvdmVyZmxvdyB8fCAoc3R5bGUgPT09IG51bGwgfHwgc3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlLm92ZXJmbG93KSB9KTtcbiAgICBpZiAodXNlVHJhbnNpdGlvbnMgJiYgYXBwbHlJbmxpbmVUcmFuc2l0aW9ucykge1xuICAgICAgICBjb21wb25lbnRTdHlsZS50cmFuc2l0aW9uID0gYGhlaWdodCAke2R1cmF0aW9ufW1zICR7ZWFzaW5nfSAke2RlbGF5fW1zYDtcbiAgICAgICAgLy8gSW5jbHVkZSB0cmFuc2l0aW9uIHBhc3NlZCB0aHJvdWdoIHN0eWxlc1xuICAgICAgICBpZiAoc3R5bGUgPT09IG51bGwgfHwgc3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0eWxlLnRyYW5zaXRpb24gPSBgJHtzdHlsZS50cmFuc2l0aW9ufSwgJHtjb21wb25lbnRTdHlsZS50cmFuc2l0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHdlYmtpdCB2ZW5kb3IgcHJlZml4IHN0aWxsIHVzZWQgYnkgb3BlcmEsIGJsYWNrYmVycnkuLi5cbiAgICAgICAgY29tcG9uZW50U3R5bGUuV2Via2l0VHJhbnNpdGlvbiA9IGNvbXBvbmVudFN0eWxlLnRyYW5zaXRpb247XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRTdHlsZSA9IHt9O1xuICAgIGlmIChhbmltYXRlT3BhY2l0eSkge1xuICAgICAgICBjb250ZW50U3R5bGUudHJhbnNpdGlvbiA9IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgJHtlYXNpbmd9ICR7ZGVsYXl9bXNgO1xuICAgICAgICAvLyBBZGQgd2Via2l0IHZlbmRvciBwcmVmaXggc3RpbGwgdXNlZCBieSBvcGVyYSwgYmxhY2tiZXJyeS4uLlxuICAgICAgICBjb250ZW50U3R5bGUuV2Via2l0VHJhbnNpdGlvbiA9IGNvbnRlbnRTdHlsZS50cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3VycmVudEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGVudFN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHVzZXIgcGFzc2VkIGFyaWEtaGlkZGVuIHByb3BcbiAgICBjb25zdCBoYXNBcmlhSGlkZGVuUHJvcCA9IHR5cGVvZiBkaXZQcm9wc1snYXJpYS1oaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgY29uc3QgYXJpYUhpZGRlbiA9IGhhc0FyaWFIaWRkZW5Qcm9wXG4gICAgICAgID8gZGl2UHJvcHNbJ2FyaWEtaGlkZGVuJ11cbiAgICAgICAgOiBoZWlnaHQgPT09IDA7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIGRpdlByb3BzLCB7IFwiYXJpYS1oaWRkZW5cIjogYXJpYUhpZGRlbiwgY2xhc3NOYW1lOiBgJHthbmltYXRpb25TdGF0ZUNsYXNzTmFtZXN9ICR7Y2xhc3NOYW1lfWAsIHN0eWxlOiBjb21wb25lbnRTdHlsZSwgcmVmOiByZWYgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNvbnRlbnRDbGFzc05hbWUsIHN0eWxlOiBjb250ZW50U3R5bGUsIHJlZjogKGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnQuY3VycmVudCA9IGVsO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSZWYuY3VycmVudCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSwgY2hpbGRyZW4pKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGVIZWlnaHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-animate-height/dist/esm/index.js\n");

/***/ })

};
;